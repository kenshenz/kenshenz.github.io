# ZeroC ICE 术语

## 客户端和服务端

* 客户端是主动方，发送请求到服务端
* 服务端是被动方，响应客户端的请求

一个端可以同时为客户端和服务端，只需要满足请求和响应的功能。

## ICE对象

ICE对象是一个抽象性或概念性的实体，可以代表以下意思：

* ICE对象是本地的（proxy）或远程的（servant）实体，它可以响应客户端请求。
* 一个ICE对象可以在一个或多个服务端中实例化。
* 每个ICE对象都有一个或多个接口，接口中包含了对象所能提供的操纵，客户端通过这些操作来请求服务端。
* 每个操作有零到多个参数，还有返回值，参数和返回值都有指定的类型。
* 每个ICE对象中都有一个特殊的接口，称为*main接口*，另外还可以提供零到多个备用接口，成为*facets*。客户端可以选择其中一个facets接口来请求。
* 每个ICE对象都有一个唯一的id。

## 代理

客户端要想跟某个ICE对象交互，必需持有这个ICE对象的代理。代理对象代表着本地或远程的ICE对象，它是某个ICE对象的大使：当客户端执行代理对象某个操作时，ICE运行时会：

1. 定位被代理的ICE对象。
2. 激活ICE对象关联的服务（没有启动的时候）。
3. 激活服务端上的ICE对象。
4. 传输参数给ICE对象。
5. 等待操作完成执行。
6. 返回响应数据到客户端（或抛出异常）。

一个代理包含了：

* 地址信息，使得客户端可以请求正确的服务端。
* 对象id，使得客户端可以找到服务端上正确的请求目标。
* 一个可选的备用接口id，用于决定代理将指向哪个接口。

### 代理字符串化（Stringified Proxies）

代理所包含的信息可以缩减成一串字符串，例如：

```
SimplePrinter:default -p 10000
```

字符串化后的代理提高了可读性。ice运行时提供了API，允许你把代理转换成字符串格式，反之亦然。这样我们就可以很方便的把代理存储到数据库表或文件中了。

### 直接代理（Direct Proxies）

直接代理即包含了对象id和服务地址信息的代理。服务地址具体为：

* 协议（例如TCP/IP或UDP）
* 地址（例如域名加端口号）

使用直接代理方式，ice运行时会使用地址信息来请求服务端，并且每个请求都会带上对象id。

### 间接代理（Indirect Proxies）

间接代理有两种形式，它可以是只提供一个对象id，或者集合对象id和对象适配器id。只用对象id就可以访问一个对象，称为well-know对象，例如：

```
SimplePrinter
```

这是一个有效的代理，被代理对象是一个id为SimplePrinter的可以确定的对象。

间接代理包含一个适配器id，如下：

```
SimplePrinter@PrinterAdapter
```

对象适配的任意对象都可以通过这个代理访问到，不管是不是well-know对象。

注意，间接代理不包含地址信息。要确定哪一个服务端，客户端会把代理信息传给本地的一个服务，该服务会通过对象id或对象适配id来检索服务表，并返回对应的服务地址信息给客户端。得到地址信息后，就可以像直接代理那样访问服务端了。（注：这就是我们常用的服务发现形式）

整个过程就好像域名和ip之间的映射一样。

### 直接绑定 vs 间接绑定

解析代理信息为具体的服务信息，我们成为绑定。毫无疑问，直接绑定使用了直接代理，间接绑定使用了间接代理。

间接绑定的最大好处是使得我们可以迁移服务，而不需要作废客户端已经拥有的代理。然而，直接代理免除了额外的服务检索工作，但当服务迁移到其他机子上时就没法工作了。

### 固态代理（Fixed Proxies）

固态代理绑定死一个特定的连接：固态代理包含一个连接句柄，而不是包含地址信息或适配器名称。当连接是open状态，代理才有用，当连接close后，代理就不能再使用了（注：即使连接重新open也不能再用）。固态代理允许双向通信，所以服务端可以直接回调客户端，而不需要open一个新的连接。

### 路由代理（Routed Proxies）

路由代理会转发所有请求到指定的对象，而不是直接发送到目标对象。路由代理在实现像[Glacier2](https://doc.zeroc.com/display/Ice36/Glacier2)这样的服务时很有用，它使得客户端可以跨过防火墙和服务端通信。

### 自我复制（Replication）

在ice中，自我复制功能使得适配器对象可以存在于多个服务端地址上，自我复制一般是为了在不同的主机上跑相同的服务，如果一台主机出问题，其他主机还可以提供服务。

当代理给对象指定了多个地址后，ice运行时会随机选择一个连接，如果失败，则会把所有连接都尝试一遍。

```
SimplePrinter:tcp -h server1 -p 10001:tcp -h server2 -p 10002
```

该代理表示id为SimplePrinter的对象可以使用两个tcp地址来请求，一个在server1主机上，一个在server2主机上。选择哪个服务的任务落在用户或者系统管理员身上。

### 自我复制组（Replica Groups）

区别于上面提到的基于代理的自我复制，ice提供了一个更加有用的自我复制功能，称为分组自我复制组，该功能需要使用[定位服务]()。

一个自我复制组有唯一的id和几个对象适配器。一个对象适配器顶多只能存在于一个自我复制组。

建立自我复制组后，它的id可以替换间接代理中的适配器id。例如，一个自我复制组id为PrinterAdapters，可以用在一个代理中，如下：

```
SimplePrinter@PrinterAdapters
```

自我复制组会被定为服务当作"virtual object adapter"来处理。在解析包含自我复制组id的间接代理时，定位服务会帮我们执行具体的细节操作。例如，当客户端的ice运行时想随机选择一个服务地址，定位服务会处理并决定返回哪一个地址。

不管定位服务用哪种方式来解析自我复制组，其最大的优点在于：定位服务作为一个中间件，可以加入更多的智能化逻辑来处理代理解析工作。

### 服务（Servants）

正如我们提及到的，ice对象是一个概念上的实体，它有一个类型、id，还有地址信息。然而，客户端的请求最终必须转到服务端具体处理逻辑的实体上。

服务端上提供具体逻辑处理的实体称为*服务者（servant）*。一个服务者为一个或多个ice对象提供服务。实际上，一个服务者就是某个类的一个实例，它由服务端开发员编写并在服务端启动时进行注册。服务者提供的操作与ice对象接口上提供的操作保持一致。

一个服务者可以同时服务一个或多个ice对象。过去，ice对象（具体体现为服务者）的id隐含在服务者里。后来，




















