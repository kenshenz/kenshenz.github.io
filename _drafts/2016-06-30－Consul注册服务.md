# 注册服务

## 定义服务

通过提供一个服务定义或调用适当的HTTP API可以注册服务。

服务定义是最常用的注册服务方式。

首先，创建一个目录，用于Consul配置。Consul会读取这个目录下的所有配置文件，在类Unix系统中，简单快捷的做法是创建`/etc/consul.d`（`.d`后缀表示该目录包含了一系列配置文件）。

```
$ sudo mkdir /etc/consul.d
```

接着，我们会写一个服务定义的配置文件。假设我们要一个名叫“web”、使用80端口的服务。另外我们还可以提供一些tag标签来便于服务的搜索

```
$ sudo tee /etc/consul.d/web.json <<< '{"service": {"name": "web", "tags": ["rails"], "port": 80}}'
```

现在，重启agent，并显示提供配置目录

```
$ consul agent -dev -config-dir /etc/consul.d
==> Starting Consul agent...
==> Starting Consul agent RPC...
==> Consul agent running!
         Node name: 'fengdeMacBook-Pro.local'
        Datacenter: 'dc1'
            Server: true (bootstrap: false)
       Client Addr: 127.0.0.1 (HTTP: 8500, HTTPS: -1, DNS: 8600, RPC: 8400)
      Cluster Addr: 192.168.1.12 (LAN: 8301, WAN: 8302)
    Gossip encrypt: false, RPC-TLS: false, TLS-Incoming: false
             Atlas: <disabled>

==> Log data will now stream in as it occurs:

    ....
    
    2016/06/30 23:44:12 [INFO] agent: Synced service 'web'
    
```

可以看到`synced service 'web'`，这表示agent成功从配置目录加载了服务，并注册到服务集里面。

如果你想注册多个服务，只需要在Consul的配置目录下定义多个服务配置文件即可。

## 查询服务

当agent启动，并且服务已经同步完毕，我们就可以使用DNS或HTTP API来查询服务。

### DNS API

对于DNS API，服务的DNS名为`NAME.service.consul`，所有DNS名默认总是使用`consul`命名空间。`service`子域告诉Consul我们正在查询服务，最后`NAME`就是我们要查询的服务的名字。

对于上面我们已经注册的服务，它的域名是`web.service.consul`

```
$ dig @127.0.0.1 -p 8600 web.service.consul

; <<>> DiG 9.8.3-P1 <<>> @127.0.0.1 -p 8600 web.service.consul
; (1 server found)
;; global options: +cmd
;; Got answer:
;; ->>HEADER<<- opcode: QUERY, status: NOERROR, id: 14989
;; flags: qr aa rd; QUERY: 1, ANSWER: 1, AUTHORITY: 0, ADDITIONAL: 0
;; WARNING: recursion requested but not available

;; QUESTION SECTION:
;web.service.consul.		IN	A

;; ANSWER SECTION:
web.service.consul.	0	IN	A	192.168.1.12

;; Query time: 4 msec
;; SERVER: 127.0.0.1#8600(127.0.0.1)
;; WHEN: Thu Jun 30 23:55:46 2016
;; MSG SIZE  rcvd: 70
```

如上面所示，IP地址前面的`A`标识表示服务可用。

你还可以使用在DNS API后面加上`SRV`标识来获取更详细的信息

```
$ dig @127.0.0.1 -p 8600 web.service.consul SRV

; <<>> DiG 9.8.3-P1 <<>> @127.0.0.1 -p 8600 web.service.consul SRV
; (1 server found)
;; global options: +cmd
;; Got answer:
;; ->>HEADER<<- opcode: QUERY, status: NOERROR, id: 39077
;; flags: qr aa rd; QUERY: 1, ANSWER: 1, AUTHORITY: 0, ADDITIONAL: 1
;; WARNING: recursion requested but not available

;; QUESTION SECTION:
;web.service.consul.		IN	SRV

;; ANSWER SECTION:
web.service.consul.	0	IN	SRV	1 1 80 fengdeMacBook-Pro.local.node.dc1.consul.

;; ADDITIONAL SECTION:
fengdeMacBook-Pro.local.node.dc1.consul. 0 IN A	192.168.1.12

;; Query time: 0 msec
;; SERVER: 127.0.0.1#8600(127.0.0.1)
;; WHEN: Fri Jul  1 23:06:41 2016
;; MSG SIZE  rcvd: 168
```

`SRV`标记说明服务正在`fengdeMacBook-Pro.local.node.dc1.consul.`主机上使用80端口运行着。下面我们尝试使用"rails"标记来查询所有web服务。

```
$ dig @127.0.0.1 -p 8600 rails.web.service.consul

; <<>> DiG 9.8.3-P1 <<>> @127.0.0.1 -p 8600 rails.web.service.consul
; (1 server found)
;; global options: +cmd
;; Got answer:
;; ->>HEADER<<- opcode: QUERY, status: NOERROR, id: 5188
;; flags: qr aa rd; QUERY: 1, ANSWER: 1, AUTHORITY: 0, ADDITIONAL: 0
;; WARNING: recursion requested but not available

;; QUESTION SECTION:
;rails.web.service.consul.	IN	A

;; ANSWER SECTION:
rails.web.service.consul. 0	IN	A	192.168.1.12

;; Query time: 1 msec
;; SERVER: 127.0.0.1#8600(127.0.0.1)
;; WHEN: Fri Jul  1 23:09:15 2016
;; MSG SIZE  rcvd: 82
```

### HTTP API

相对于DNS API，HTTP API是这样查询服务的

```
$ curl http://127.0.0.1:8500/v1/catalog/service/web
[{"Node":"fengdeMacBook-Pro.local","Address":"192.168.1.12","ServiceID":"web","ServiceName":"web","ServiceTags":["rails"],"ServiceAddress":"","ServicePort":80,"ServiceEnableTagOverride":false,"CreateIndex":5,"ModifyIndex":5}]
```

catalog API返回了所有包含我们查询的服务的节点。下面我们再来查询一下处于健康状态下的服务

```
$ curl http://127.0.0.1:8500/v1/catalog/service/web?passing
[{"Node":"fengdeMacBook-Pro.local","Address":"192.168.1.12","ServiceID":"web","ServiceName":"web","ServiceTags":["rails"],"ServiceAddress":"","ServicePort":80,"ServiceEnableTagOverride":false,"CreateIndex":5,"ModifyIndex":5}]
```

### 更新服务

想要更新服务，需要先修改配置文件，然后发送`SIGHUP`命令到代理。这样我们就可以在不中断服务或使服务失效的情况下更新服务了。

另外，也可以使用HTTP API来动态新增、删除和修改服务。































